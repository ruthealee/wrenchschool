## Introduction to the CLI
The command line interface or CLI just means interacting with your computer via text commands as opposed to mouse clicks and what we'd refer to as a 'graphical user interface' or GUI. 

For example, to launch spotify on your mac, you might double click the icon in the dock. That's interacting with the graphical representation of the application. To do the same from the CLI we open a terminal and type './spotify' to run the application.

## Why Use the CLI?
Getting started with the CLI can seem daunting, especially if you're not used to the command names and syntax but it's definitely worth the initial sharp learning curve. 

On top of making you look like you're in the Matrix the CLI has a number of benefits. The biggest ones are speed and automation. Here's an example, I want to create a batch of 50 files named: file1, file2, file3 etc. That's going to take a long time to do using the graphical interface. With the cli I can run this:

```
touch file{1..50}
```
Much faster! The other benefit is that the cli allows me to interact with my computer in a way that is easily adaptable to code. If I want to automatically create those file when I log into the machine there are ways to do this (see: apple scripts) but it's much easier for me to simply add that line to the end of a file that runs on login. (If you've ever used 'automater' on your mac it's translating the GUI clicks into CLI instructions). 

## Getting Started
The first thing we'll need is a terminal. Mac has a built in terminal in applications, or you can download a program called iTerm2. This is most people's preference as it has a more fully fledged feature set. It doesn't matter which you use to start though.

When you open a terminal you'll be dumped into a command line prompt. This will look something like:

```
my-mbp/Users/myuser/home $ 
```

The text is telling us something about our computer. It's usually prefaced by the computer's hostname, the current working directory (where we are located on the fiesystem) and then a special character indicating that it's a terminal prompt. (In this case it's the $ sign, but you might sometimes see #. This changes based on the privilege of the user you're utilising to perform commands, but they both meant the same thing.)

You'll notice some people have customised their command line prompt and you can start doing this as you become more familiar. Here's what some of these might look like:

```
#rlee@earth::~/git/wrenchschool [master ✔] [12:55:18]$
```

You can see I've customised mine to show my username, the hostname of my machine. Then I have my path, and a git specific add on that shows me what branch of my repository i'm on and whether my local directory is up to date with my remote directory, and the current time.

### Navigating the CLI
In order to move around our filesystem's directories there's one main command we use and that is:
```
cd
```
This stands for 'change directory'. We can use it to go to a directory directly like this:

```
cd /Users/rlee/git/wrenchschool
```

It's important to understand the difference between *absolute* and *relative* paths. An absolute path provides the full instructions for reaching a location, a relative path provides instructions from the point you're currently at. 

A good analogy is:

In order to get from home to work the directions are given precisely as follows:

> "From your house take the first left, then then the second right, the third right, and finally the next left." 

Assuming all your journeys start from your house, (in computer terms, our root filesystem) that would be an absolute path. 

Now let's assume you've already left the house and taken the first two turns. I can give you the instructions two ways now, I can tell you the exact same as above, and you can work out well i've already taken the first two turns. Or, I can just give you the turns you need and say:

> "Take the third right and the next left."

That will get you to work, but those instructions are *relative* to your current path. If you'd only taken the first turn from the full set of instructions you'd now be in the wrong place!

Relative paths are quicker to give since they miss off some information, but they can trip you up if you, or your program, isn't where you think you are. 

If you forget your path you can always type ```pwd``` to get the full path returned to you.

We can see what is in our current directory by typing ```ls -lah```
(list!)
This gives us an output like this:

```
#rlee@earth::~/git/wrenchschool [master ✔] [13:07:55]$ ls -lah
total 40
drwxr-xr-x  10 rlee  staff   340B 13 Jun 12:42 .
drwxr-xr-x  27 rlee  staff   918B 13 Jun 11:50 ..
drwxr-xr-x  15 rlee  staff   510B 13 Jun 13:07 .git
-rw-r--r--   1 rlee  staff    52B 22 May 17:54 .gitignore
-rw-r--r--   1 rlee  staff   609B 22 May 18:09 README.md
-rw-r--r--   1 rlee  staff    29B 22 May 18:05 _config.yml
drwxr-xr-x   2 rlee  staff    68B 22 May 18:10 images
-rw-r--r--   1 rlee  staff   716B 22 May 18:14 index.md
-rw-r--r--   1 rlee  staff   2.9K 22 May 18:12 intro-level-resources.md
drwxr-xr-x   2 rlee  staff    68B 13 Jun 12:42 workshops```

You'll notice some files seem emphasised, that's because they are telling you something about themselves. In this case it's usually that they are directories. You can tell a directory by the way it is emphasised in your terminal (this is customisable too!) or by looking for the 'd' at the beginning of the first column. Don't worry about what all the columns mean for now, just look at the name on the far right, and whether or not it has a 'd' as the first character in the first column. 

Now we have the names of some directories we can cd into them and look around.  

```
cd workshops
```
You'll not that we used a *relative* path there. We could also have done this:

```
#rlee@earth::~/git/wrenchschool [master ✔] [13:12:26]$ pwd
/Users/rlee/git/wrenchschool
#rlee@earth::~/git/wrenchschool [master ✔] [13:12:29]$ cd /Users/rlee/git/wrenchschool/workshops

```
Here you can see I found the full path of where I was currently, and added the directory I wanted to navigate to at the end. 

If you want to go back 'up' a level you can either check the current path with pwd and then delete directories as desired to navigate back or you could use a shortcut:

```
cd ..
```

You might have noticed that in the earlier output of files in a directory we saw two files named '. and '..' these are shortcut files to help us navigate the directories. They mean 'this directory' and 'my parent directory' respectively.

I can use these to do things like copy a file to my current directory by typing:
```
cp <filea> .
```
Instead of having to write the full path like ```cp <filea> /Users/rlee/git/wrenchschool```

Test out navigating around some directories now. If you're not sure of the absolute path of a directory here's some examples:

```
/Users/$yourusername/Documents/
```

Remember you can use ```pwd``` and ```cd ..```. If you get 'lost' in the filesystem you can always use this command to return to your users home folder: ```cd ~ ```
The tilde means 'my home folder'. 



